# Платформенная часть

## Сервер и соединения
Проект включает в себя реализацию сервера, который обрабатывает входящие HTTP-запросы. Основные классы платформенной части обеспечивают взаимодействие между клиентами и сервером, а также маршрутизацию запросов.

#### Основные классы:

1. **`MyBootApplication`**
   - Этот класс отвечает за запуск приложения. Он обрабатывает командные аргументы, выполняет миграцию базы данных и запускает сервер.
   - **Методы:**
     - `run(String[] args)`: Начинает выполнение приложения, обрабатывая аргументы командной строки и инициализируя сервер.

2. **`MyServer`**
   - Класс, отвечающий за создание серверного сокета и прослушивание входящих соединений. Он использует пул потоков для обработки запросов клиентов.
   - **Методы:**
     - `run(Integer port)`: Запускает сервер на указанном порту, принимает входящие соединения и создает новые потоки для обработки клиентов.

3. **`HttpConnection`**
   - Этот класс представляет собой соединение с клиентом. Он отвечает за чтение HTTP-запроса, его обработку и отправку ответа обратно клиенту.
   - **Методы:**
     - `run()`: Основной метод, который обрабатывает входящие запросы, парсит их и отправляет ответ с использованием маршрутизатора.

4. **`RequestReader`**
   - Класс, предназначенный для чтения HTTP-запросов из сокета. Он обрабатывает заголовки и тело запроса, а также определяет длину содержимого.
   - **Методы:**
     - `read(Socket socket)`: Читает входящий запрос из сокета и возвращает его в виде строки.

5. **`RequestWriter`**
   - Этот класс отвечает за отправку HTTP-ответов обратно клиенту.
   - **Методы:**
     - `write(Socket socket, String response)`: Записывает ответ в сокет и закрывает поток.

#### Архитектура

Серверная часть проекта построена на архитектуре, основанной на обработке соединений через сокеты. При запуске сервер слушает указанный порт и принимает входящие соединения от клиентов. Для каждого соединения создается новый экземпляр `HttpConnection`, который обрабатывает запросы в отдельном потоке. Это позволяет серверу одновременно обрабатывать несколько запросов.

Запросы от клиентов сначала считываются с помощью класса `RequestReader`, который парсит заголовки и тело запроса. После этого `HttpConnection` использует маршрутизатор (`HttpRouter`), чтобы определить, как обрабатывать запрос. Ответ формируется и отправляется обратно клиенту с помощью класса `RequestWriter`.

## Запросы

В этой части проекта реализуется структура для обработки HTTP-запросов. Основные классы управляют парсингом запросов, их заголовками и телами, а также маршрутизацией запросов.

#### Основные классы:

1. **`AbstractRequest`**
   - Абстрактный класс, представляющий общий интерфейс для всех типов запросов.
   - **Методы:**
     - `getParser()`: Возвращает парсер для обработки запроса.

2. **`RequestParser`**
   - Интерфейс для парсеров запросов.
   - **Методы:**
     - `AbstractRequest parse(String request)`: Парсит строку запроса и возвращает экземпляр `AbstractRequest`.

3. **`HttpRequest`**
   - Абстрактный класс, расширяющий `AbstractRequest`. Он включает заголовки и тело HTTP-запроса.
   - **Методы:**
     - `getBody()`: Возвращает тело HTTP-запроса.
     - `getHead()`: Возвращает заголовки HTTP-запроса.

4. **`HttpRequestHead`**
   - Класс, представляющий заголовки HTTP-запроса, включая метод, URL, заголовки и параметры.
   - **Методы:**
     - `getMethod()`, `setMethod(MyHttpRequestMethod method)`: Получает и устанавливает метод запроса.
     - `getUrl()`, `setUrl(String url)`: Получает и устанавливает URL запроса.
     - `getHeaders()`, `setHeaders(MyHttpHeaders headers)`: Получает и устанавливает заголовки запроса.
     - `getParams()`, `setParams(MyHttpParams params)`: Получает и устанавливает параметры запроса.

5. **`HttpRequestBody`**
   - Абстрактный класс, представляющий тело HTTP-запроса.
   - **Методы:**
     - `getStringRepresentation()`: Возвращает строковое представление тела запроса.

6. **`MyHttpRequestMethod`**
   - Перечисление, представляющее возможные HTTP-методы (GET, POST, PUT, DELETE, PATCH).

7. **`ParametrizedHttpRequest`**
   - Класс, представляющий параметризованный HTTP-запрос с телом, которое может быть распарсено в заданный тип.
   - **Методы:**
     - `fromRaw(HttpRequest request, Type type)`: Создает параметризованный HTTP-запрос из сыро́го запроса.

8. **`ParametrizedHttpRequestBody`**
   - Класс, представляющий тело параметризованного HTTP-запроса. Содержит методы для парсинга JSON-содержимого.
   - **Методы:**
     - `parseContent()`: Парсит содержимое тела запроса в объект указанного типа.

9. **`RawHttpRequest`**
   - Класс, представляющий "сыро́й" HTTP-запрос.
   - **Методы:**
     - `getBody()`: Возвращает тело сыро́го запроса.

10. **`RawHttpRequestParser`**
    - Класс, отвечающий за парсинг сыро́го HTTP-запроса.
    - **Методы:**
      - `parse(String request)`: Парсит сыро́й запрос и возвращает экземпляр `RawHttpRequest`.

11. **`HttpRequestParser`**
    - Интерфейс для парсинга HTTP-запросов, расширяющий `RequestParser`. Содержит методы для парсинга заголовков и тела запроса.
    - **Методы:**
      - `parseHead(String requestHead)`: Парсит заголовки HTTP-запроса.
      - `parse(String request)`: Парсит полный HTTP-запрос.

#### Архитектура

Запросы обрабатываются через иерархию классов, начиная с абстрактного класса `AbstractRequest`. Конкретные запросы, такие как `RawHttpRequest` и `ParametrizedHttpRequest`, наследуют этот класс и реализуют специфические для них методы. Парсинг запросов осуществляется с помощью соответствующих парсеров (`RawHttpRequestParser`, `ParametrizedHttpRequestParser`), которые разбирают запрос на заголовки и тело.

При получении запроса сервер использует соответствующий парсер для его обработки. Заголовки и тело запроса обрабатываются и хранятся в объектах `HttpRequestHead` и `HttpRequestBody`. Параметры запроса обрабатываются с помощью класса `MyHttpParams`, что позволяет эффективно управлять параметрами в URL.

## Ответы

В этой части проекта реализуется структура для формирования и обработки HTTP-ответов. Классы управляют заголовками, телами ответов и их форматированием.

#### Основные классы:

1. **`AbstractResponse`**
   - Абстрактный класс, представляющий общий интерфейс для всех типов ответов.
   - **Методы:**
     - `getFormatted()`: Возвращает форматированный ответ в виде строки.
     - `getBuilder()`: Возвращает строителя для формирования ответа.

2. **`HttpResponse<T>`**
   - Класс, представляющий HTTP-ответ с заголовками и телом.
   - **Методы:**
     - `getHead()`: Возвращает заголовки ответа.
     - `getBody()`: Возвращает тело ответа.
     - `getFormatted()`: Форматирует ответ в строку для отправки клиенту.
     - Статические методы для создания ответов с различными статусами:
       - `ok(String bodyContent)`: Создает ответ с кодом 200 и телом.
       - `badRequest(String message)`: Создает ответ с кодом 400 и сообщением.
       - `internalServerError(String message)`: Создает ответ с кодом 500 и сообщением.

3. **`HttpResponseBody<T>`**
   - Класс, представляющий тело HTTP-ответа.
   - **Методы:**
     - `getContent()`: Возвращает содержимое тела.
     - `fromType(T value)`: Создает тело ответа на основе переданного значения.

4. **`HttpResponseBuilder`**
   - Класс-строитель для создания экземпляров `HttpResponse`.
   - **Методы:**
     - `addHeader(String key, String value)`: Добавляет заголовок к ответу.
     - `setStatus(HttpResponseStatus status)`: Устанавливает статус ответа.
     - `setBody(T body)`: Устанавливает тело ответа.
     - `build()`: Создает и возвращает экземпляр `HttpResponse`.

5. **`HttpResponseHead`**
   - Класс, представляющий заголовки HTTP-ответа.
   - **Методы:**
     - `getHeaders()`: Возвращает заголовки ответа.
     - `setHeaders(MyHttpHeaders headers)`: Устанавливает заголовки ответа.
     - `getStatus()`: Возвращает статус ответа.

6. **`HttpResponseStatus`**
   - Класс, представляющий статус HTTP-ответа.
   - **Методы:**
     - `getCode()`: Возвращает код статуса.
     - `getDescription()`: Возвращает описание статуса на основе кода.

#### Архитектура

Ответы формируются через иерархию классов, начиная с абстрактного класса `AbstractResponse`. Конкретные реализации, такие как `HttpResponse`, обеспечивают специфические методы для форматирования и отправки ответов клиенту.

Строитель ответов (`HttpResponseBuilder`) позволяет гибко настраивать заголовки, статус и тело ответа. Это упрощает создание ответов с различными конфигурациями.

Тела ответов обрабатываются классом `HttpResponseBody`, который может хранить объекты различных типов. Это позволяет отправлять как простые текстовые сообщения, так и более сложные структуры данных в формате JSON.

## Маршрутизация

Эта часть платформы отвечает за маршрутизацию входящих HTTP-запросов к соответствующим обработчикам. Она обеспечивает сопоставление URL-адресов и методов HTTP с определенными действиями в приложении.

#### Основные интерфейсы и классы:

1. **`HttpRouter`**
   - Интерфейс для маршрутизатора, который обрабатывает HTTP-запросы.
   - **Методы:**
     - `handle(HttpRequest request)`: Обрабатывает входящий HTTP-запрос и возвращает соответствующий HTTP-ответ.

2. **`HttpRouterNavigator`**
   - Интерфейс для навигации по сегментам маршрута.
   - **Методы:**
     - `getEndpoint()`: Возвращает текущий конечный пункт маршрута.
     - `getFilters()`: Возвращает текущие фильтры маршрута.
     - `navigate(String pattern)`: Перемещает к следующему сегменту маршрута на основе заданного шаблона.

3. **`HttpRouterSegment`**
   - Интерфейс для сегмента маршрута.
   - **Методы:**
     - `addMapping(String pattern)`: Добавляет новый сегмент маршрута с указанным шаблоном.
     - `back()`: Возвращает к предыдущему сегменту маршрута.
     - `setupEndpoint()`: Настраивает конечный пункт маршрута.
     - `setupFilters()`: Настраивает фильтры маршрута.
     - `getNavigator()`: Получает навигатор маршрута.

4. **`HttpFilterSegment`**
   - Интерфейс для сегмента фильтров.
   - **Методы:**
     - `addFilter(Supplier<? extends HttpFilterHandler> filterProd)`: Добавляет фильтр в сегмент.
     - `getFilters()`: Получает список фильтров.
     - `endSetup()`: Завершает настройку и возвращает связанный сегмент маршрута.

5. **`HttpFilterHandler`**
   - Интерфейс для обработчика фильтров.
   - **Методы:**
     - `filter(HttpRequest request, HttpResponseBuilder response)`: Применяет фильтр к запросу и строит ответ.

6. **`HttpEndpoint`**
   - Интерфейс для конечного пункта маршрута.
   - **Методы:**
     - `addEndpoint(Supplier<? extends HttpEndpointHandler> endpointHandler)`: Добавляет обработчик конечного пункта.
     - `getEndpoint()`: Получает обработчик конечного пункта.

7. **`HttpEndpointHandler`**
   - Интерфейс для обработчиков конечных пунктов.
   - **Методы:**
     - `handle(ParametrizedHttpRequest request, HttpResponseBuilder builder)`: Обрабатывает входящий запрос и возвращает HTTP-ответ.
     - `getExpectedBodyType()`: Возвращает ожидаемый тип тела запроса.

8. **`DefaultHttpRouter`**
   - Класс по умолчанию для реализации маршрутизатора.
   - **Методы:**
     - `handle(HttpRequest request)`: Обрабатывает входящий HTTP-запрос, применяя фильтры и настраивая конечные пункты.

#### Архитектура

Маршрутизация построена на принципе сопоставления между маршрутами и входящими запросами. При получении HTTP-запроса маршрутизатор разбивает URL на сегменты и проверяет соответствие каждому сегменту, применяя связанные фильтры и обрабатывая конечные пункты.

- Если фильтры возвращают положительный результат, маршрутизатор вызывает обработчик конечного пункта.
- Если фильтры препятствуют дальнейшей обработке, маршрутизатор возвращает соответствующий ответ.
- При отсутствии маршрута или ошибке маршрутизация возвращает ответ с кодом ошибки.

#### Пример использования

```java
HttpRouterSegment root = new HttpRouterSegmentImpl("/api");

root.addMapping("/users")
    .setupFilters()
        .addFilter(() -> new MyFilter())
    .endSetup()
    .setupEndpoint()
        .addEndpoint(() -> new UserHandler())
    .endSetup();

DefaultHttpRouter router = new DefaultHttpRouter(root);

HttpResponse<?> response = router.handle(request);
```

#### Маршрутизация: итоги

С помощью этого интерфейса разработчики могут легко настраивать маршрутизацию, 
добавляя новые сегменты, фильтры и конечные пункты 
по мере необходимости.
Это обеспечивает гибкость и расширяемость платформы.

## Безопасность... такая спорная безопасность.

Эта часть платформы отвечает за аутентификацию пользователей, управление сессиями и шифрование паролей. Она обеспечивает механизмы для работы с учетными данными пользователей и токенами аутентификации.

_не смотрите что это чем-то похоже на Spring Security, это просто совпадение;)_

#### Основные интерфейсы и классы:

1. **`UserDetails`**
   - Интерфейс, представляющий детали пользователя.
   - **Методы:**
     - `getUsername()`: Возвращает имя пользователя.
     - `getPassword()`: Возвращает зашифрованный пароль.

2. **`UserDetailsService`**
   - Интерфейс для загрузки данных пользователя по имени пользователя.
   - **Методы:**
     - `loadUserByUsername(String username)`: Загружает учетные данные пользователя по имени пользователя.

3. **`SecurityContext`**
   - Интерфейс для управления контекстом безопасности и токенами аутентификации.
   - **Методы:**
     - `setAuthentication(Authentication authentication)`: Устанавливает аутентификацию и возвращает уникальный идентификатор.
     - `getAuthentication(String uuid)`: Получает аутентификацию по уникальному идентификатору.
     - `removeAuthentication(String token)`: Удаляет аутентификацию по токену.

4. **`PasswordEncoder`**
   - Интерфейс для шифрования паролей.
   - **Методы:**
     - `matches(String rawPassword, String encodedPassword)`: Проверяет, соответствует ли необработанный пароль зашифрованному.
     - `encode(String password)`: Шифрует пароль.

5. **`AuthenticationToken`**
   - Интерфейс для токена аутентификации.
   - **Методы:**
     - `getUserDetails()`: Получает детали пользователя.

6. **`Authentication`**
   - Интерфейс для аутентификации пользователя.
   - **Методы:**
     - `getPrincipal()`: Получает основные данные пользователя.
     - `isAuthenticated()`: Проверяет, аутентифицирован ли пользователь.

7. **`SecurityContextImpl`**
   - Реализация контекста безопасности.
   - **Методы:**
     - `setAuthentication(Authentication authentication)`: Устанавливает аутентификацию и сохраняет ее в мапе.
     - `getAuthentication(String uuid)`: Возвращает аутентификацию по идентификатору.
     - `removeAuthentication(String token)`: Удаляет аутентификацию.

8. **`AuthenticationTokenImpl`**
   - Реализация токена аутентификации.
   - **Методы:**
     - `getUserDetails()`: Возвращает детали пользователя.

9. **`AuthenticationImpl`**
   - Реализация аутентификации.
   - **Методы:**
     - `getPrincipal()`: Возвращает основные данные пользователя.
     - `isAuthenticated()`: Возвращает статус аутентификации.

10. **`ApiKeyGenerator`**
    - Класс для генерации и проверки API-ключей.
    - **Методы:**
      - `generateApiKey()`: Генерирует новый API-ключ.
      - `isValidApiKey(String apiKey, String other)`: Проверяет, действителен ли API-ключ.

11. **`InMemoryUserDetailsService`**
    - Реализация сервиса загрузки данных пользователя с использованием хранилища в памяти.
    - **Методы:**
      - `loadUserByUsername(String username)`: Загружает учетные данные пользователя из хранилища.

12. **`SimplePasswordEncoder`**
    - Реализация шифрования паролей.
    - **Методы:**
      - `matches(String rawPassword, String encodedPassword)`: Проверяет соответствие паролей.
      - `encode(String password)`: Шифрует пароль.

#### Архитектура

Механизм безопасности построен на основе аутентификации и управления сессиями. Пользователь вводит свои учетные данные, которые проверяются с помощью сервиса `UserDetailsService`. Если учетные данные верны, создается объект `Authentication`, который сохраняется в `SecurityContext`. Токен аутентификации (API-ключ) генерируется и используется для последующих запросов.

#### Пример использования

```java
UserDetailsService userDetailsService = new InMemoryUserDetailsService();
PasswordEncoder passwordEncoder = new SimplePasswordEncoder();
SecurityContext securityContext = new SecurityContextImpl(new ApiKeyGenerator());

String username = "alex";
String rawPassword = "root";
UserDetails userDetails = userDetailsService.loadUserByUsername(username);

if (userDetails != null && passwordEncoder.matches(rawPassword, userDetails.getPassword())) {
    Authentication authentication = new AuthenticationImpl(userDetails, true);
    String token = securityContext.setAuthentication(authentication);
    System.out.println("Authenticated! Token: " + token);
} else {
    System.out.println("Authentication failed.");
}
```

### Платформенная часть: итоги

Итак, давай подведем итоги о нашей платформе, которую мы построили. Это, конечно, не что-то, что можно будет запустить в продакшн или использовать для реальных задач, но процесс разработки был увлекательным!

#### Достоинства

- **Архитектурная гибкость**: Мы применили различные паттерны, такие как **стратегия** (для маршрутизации и обработки запросов), **построитель** (для формирования ответов), и даже **фабрики** (для создания объектов). Это позволяет легко расширять платформу, добавлять новые функциональности и тестировать различные компоненты.
  
- **Модульность**: Каждый компонент (маршрутизация, безопасность, обработка запросов) разделен на интерфейсы и реализации, что дает возможность подключать свои версии и переиспользовать код.

- **Простота тестирования**: Благодаря хорошо определенным интерфейсам, можно легко писать юнит-тесты. Например, создавая собственные реализации `UserDetailsService` или `HttpRouter`, можно протестировать их отдельно.

#### Возможности

- **Расширяемость**: Пользователи могут сами добавлять маршруты, фильтры и обработчики, реализуя предоставленные интерфейсы. Это создает возможность кастомизации под специфические нужды.

- **Безопасность**: Хотя она и не на уровне банковского приложения, основа для аутентификации и шифрования паролей уже заложена. Можно развивать эту часть и добавлять более сложные механизмы, если будет желание.

- **Поддержка JSON**: Мы сделали акцент на JSON как формате обмена данными, что соответствует современным требованиям веб-разработки.

#### Преимущества

- **Легкость в использовании**: Если вы решите собрать свою мини-платформу, это можно сделать быстро. Платформа предоставляет базовые структуры, на которых можно строить свои идеи.

- **Учебный проект**: Если вы хотите понять основы работы с HTTP, маршрутизацией и безопасностью, то это отличный проект для начала. Он прост, но в то же время дает представление о принципах работы более крупных систем.

#### Недостатки

- **Не для боевого применения**: В таком виде платформу, конечно, не стоит использовать в реальных проектах. Она не покрывает все аспекты безопасности, обработки ошибок и масштабируемости.

- **Ограниченные возможности безопасности**: Как я уже говорил, безопасность реализована на базовом уровне. Если кто-то захочет серьезно заняться защитой данных, тут придется потрудиться.

- **Сложность поддержки**: Без хорошей документации и структуры кода может возникнуть путаница. Хотя мы сделали все в модульном стиле, без четких указаний и примеров новичку будет сложно разобраться.

#### Заключение

В общем, это не просто код, а скорее эксперимент! Платформа — это возможность поиграть с архитектурными подходами и паттернами, а также освоить основы работы с HTTP и безопасностью. У кого-то может возникнуть желание развить это дальше, и это будет здорово! А пока — просто наслаждайтесь процессом, создавая свои собственные маршруты и пользователи.


## Вторая часть: начало

Теперь, когда мы успешно закончили реализацию платформы и изучили архитектуру, паттерны и основные компоненты, можно с гордостью сказать, что основа заложена. Первая часть проекта сосредоточилась на разработке HTTP-протокола с нуля, включая маршрутизацию, обработку запросов и безопасность. Мы применили несколько интересных подходов и паттернов, которые помогут нам в дальнейшем.

### Что ждет?

Вторая часть нашего проекта будет посвящена созданию **платформы и API**. Основная цель этой фазы — расширить функциональность, добавив возможность взаимодействия с пользователями и приложениями через API. Вот несколько ключевых направлений, которые мы собираемся реализовать:

### Архитектура платформы

- **RESTful API**: Построим API, который будет поддерживать все основные CRUD операции (создание, чтение, обновление, удаление).
- **Модульная структура**: Подход с разделением на модули позволит легче управлять кодом и добавлять новые функции без значительных изменений в существующих компонентах.
- **Работа с БД**: Подкрутим сюда постгрес

# Архитектура платформы

## Общее описание

В этом разделе рассматриваются ключевые аспекты архитектуры нашего проекта, включая подключение Spring контекста, JPA и Flyway для управления миграциями базы данных. Мы используем модульный подход, который обеспечивает гибкость и простоту расширения.

## Подключение Spring контекста

Spring контекст подключается с помощью аннотации `@Configuration`, что позволяет нам определять бины и настраивать приложение. Мы также используем `@ComponentScan` для автоматического обнаружения и регистрации компонентов, таких как сервисы и репозитории, в указанном пакете. Это позволяет нам легко управлять зависимостями и конфигурацией приложения.

## Настройка JPA

Для работы с базой данных мы используем Spring Data JPA, что позволяет нам эффективно взаимодействовать с сущностями и упрощает реализацию CRUD операций. JPA конфигурируется через аннотацию `@EnableJpaRepositories`, что позволяет автоматически создавать репозитории на основе интерфейсов. Мы также настраиваем `EntityManagerFactory` и `PlatformTransactionManager` для управления транзакциями и сущностями.

### Описание бинов JPA:

- **DataSource**: Бин, отвечающий за соединение с базой данных PostgreSQL. Он управляет настройками подключения, такими как URL, имя пользователя и пароль.

- **LocalContainerEntityManagerFactoryBean**: Бин, который настраивает фабрику для создания экземпляров `EntityManager`, необходимых для работы с сущностями.

- **PlatformTransactionManager**: Бин для управления транзакциями в приложении, обеспечивая поддержку ACID-свойств.

## Управление миграциями с помощью Flyway

Flyway интегрирован в проект для автоматизации миграций базы данных. Мы настраиваем Flyway для использования с PostgreSQL, что позволяет нам управлять схемой базы данных и легко применять изменения. Это обеспечивает удобное и безопасное управление версиями базы данных, позволяя нам легко откатывать и применять миграции при необходимости.

### Описание бинов Flyway:

- **Flyway**: Бин, который управляет миграциями базы данных. Он загружает скрипты миграции из указанного каталога и применяет их к базе данных.

## Общее описание роутера

Роутер в нашем проекте отвечает за маршрутизацию HTTP-запросов к соответствующим обработчикам на основе заданных URL-путей. Он обеспечивает централизованное управление маршрутами и фильтрами, что делает архитектуру более понятной и упрощает добавление новых конечных точек. Мы реализуем роутер с помощью классов, отвечающих за конкретные сегменты маршрутов, что позволяет удобно настраивать и расширять его функциональность.

### Описание бинов роутера:

- **HttpRouter**: Главный бин, который управляет маршрутизацией запросов. Он определяет структуру маршрутов и связывает их с соответствующими обработчиками.

- **HttpRouterSegment**: Бин, который представляет собой сегмент маршрута. Он может содержать подмаршруты и определяет, какие фильтры и обработчики будут применяться для конкретного сегмента.

- **Endpoint Handlers**: Бины, которые обрабатывают запросы для конкретных конечных точек, таких как регистрация, аутентификация и работа с рабочими пространствами. Каждый обработчик отвечает за свою часть бизнес-логики и взаимодействие с сервисами.


### Архитектура платформы

#### Общее описание

В этом разделе рассматриваются ключевые аспекты архитектуры нашего проекта, включая подключение Spring контекста, JPA и Flyway для управления миграциями базы данных. Мы используем модульный подход, который обеспечивает гибкость и простоту расширения.

#### Подключение Spring контекста

Spring контекст подключается с помощью аннотации `@Configuration`, что позволяет нам определять бины и настраивать приложение. Мы также используем `@ComponentScan` для автоматического обнаружения и регистрации компонентов, таких как сервисы и репозитории, в указанном пакете. Это позволяет нам легко управлять зависимостями и конфигурацией приложения.

#### Настройка JPA

Для работы с базой данных мы используем Spring Data JPA, что позволяет нам эффективно взаимодействовать с сущностями и упрощает реализацию CRUD операций. JPA конфигурируется через аннотацию `@EnableJpaRepositories`, что позволяет автоматически создавать репозитории на основе интерфейсов. Мы также настраиваем `EntityManagerFactory` и `PlatformTransactionManager` для управления транзакциями и сущностями.

##### Описание бинов JPA:

- **DataSource**: Бин, отвечающий за соединение с базой данных PostgreSQL. Он управляет настройками подключения, такими как URL, имя пользователя и пароль.

- **LocalContainerEntityManagerFactoryBean**: Бин, который настраивает фабрику для создания экземпляров `EntityManager`, необходимых для работы с сущностями.

- **PlatformTransactionManager**: Бин для управления транзакциями в приложении, обеспечивая поддержку ACID-свойств.

#### Управление миграциями с помощью Flyway

Flyway интегрирован в проект для автоматизации миграций базы данных. Мы настраиваем Flyway для использования с PostgreSQL, что позволяет нам управлять схемой базы данных и легко применять изменения. Это обеспечивает удобное и безопасное управление версиями базы данных, позволяя нам легко откатывать и применять миграции при необходимости.

##### Описание бинов Flyway:

- **Flyway**: Бин, который управляет миграциями базы данных. Он загружает скрипты миграции из указанного каталога и применяет их к базе данных.

#### Общее описание роутера

Роутер в нашем проекте отвечает за маршрутизацию HTTP-запросов к соответствующим обработчикам на основе заданных URL-путей. Он обеспечивает централизованное управление маршрутами и фильтрами, что делает архитектуру более понятной и упрощает добавление новых конечных точек. Мы реализуем роутер с помощью классов, отвечающих за конкретные сегменты маршрутов, что позволяет удобно настраивать и расширять его функциональность.

##### Описание бинов роутера:

- **HttpRouter**: Главный бин, который управляет маршрутизацией запросов. Он определяет структуру маршрутов и связывает их с соответствующими обработчиками.

- **HttpRouterSegment**: Бин, который представляет собой сегмент маршрута. Он может содержать подмаршруты и определяет, какие фильтры и обработчики будут применяться для конкретного сегмента.

- **Endpoint Handlers**: Бины, которые обрабатывают запросы для конкретных конечных точек, таких как регистрация, аутентификация и работа с рабочими пространствами. Каждый обработчик отвечает за свою часть бизнес-логики и взаимодействие с сервисами.

### Репозитории и БД

#### Архитектура БД

В нашей базе данных мы используем несколько таблиц для хранения информации о пользователях, рабочих пространствах, страницах, блоках и разрешениях. Вот краткое описание структуры таблиц:

- **Users**: Хранит информацию о пользователях, включая уникальное имя пользователя и хеш пароля.
  
- **Workspaces**: Связывает рабочие пространства с их владельцами. Каждое рабочее пространство принадлежит конкретному пользователю.

- **Pages**: Содержит страницы, которые могут принадлежать различным рабочим пространствам и могут иметь иерархическую структуру (родительские страницы).

- **Blocks**: Хранит содержимое страниц в виде блоков. Каждый блок может быть текстом или изображением.

- **Permissions**: Определяет разрешения пользователей для конкретных страниц. Разрешения могут быть на чтение или запись.

##### SQL-схема

```sql
CREATE TABLE Users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash TEXT NOT NULL
);

CREATE TABLE Workspaces (
    id SERIAL PRIMARY KEY,
    owner_id INT REFERENCES Users(id),
    name VARCHAR(100) NOT NULL
);

CREATE TABLE Pages (
    id SERIAL PRIMARY KEY,
    workspace_id INT REFERENCES Workspaces(id),
    parent_page_id INT REFERENCES Pages(id),
    title VARCHAR(255),
    content TEXT
);

CREATE TABLE Blocks (
    id SERIAL PRIMARY KEY,
    page_id INT REFERENCES Pages(id),
    type VARCHAR(50), -- "text", "image"
    content TEXT
);

CREATE TABLE Permissions (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES Users(id),
    page_id INT REFERENCES Pages(id),
    permission_type VARCHAR(50) -- "read", "write"
);
```
#### Репозитории
Репозитории обеспечивают доступ к данным и взаимодействие с базой данных. Мы используем Spring Data JPA для автоматизации работы с репозиториями. Каждый репозиторий предоставляет основные CRUD операции и специализированные методы для работы с конкретными сущностями.
##### Описание репозиториев:
- **UserRepository**: Позволяет выполнять операции с пользователями. Имеет метод findByUsername, чтобы находить пользователей по имени.
- **WorkspaceRepository**: Позволяет управлять рабочими пространствами. Имеет метод findByOwnerId, чтобы получать рабочие пространства, принадлежащие конкретному пользователю.
- **PageRepository**: Позволяет работать со страницами. Имеет метод findByWorkspaceId, чтобы находить страницы по идентификатору рабочего пространства.
- **BlockRepository**: Управляет блоками на страницах. Имеет метод findByPageId, чтобы получать блоки по идентификатору страницы.
- **PermissionRepository**: Обрабатывает разрешения для страниц. Имеет метод findByPageId, чтобы находить разрешения, связанные с конкретной страницей.

### Сервисы

В нашем приложении реализованы несколько сервисов, каждый из которых отвечает за определенную область функциональности. Сервисы обеспечивают бизнес-логику, необходимую для работы с данными, и взаимодействуют с репозиториями для выполнения операций.

#### AuthenticationService

- **Назначение**: Обрабатывает аутентификацию и регистрацию пользователей.
- **Основные методы**:
  - `authenticate(String username, String password)`: Проверяет учетные данные пользователя и устанавливает аутентификацию.
  - `register(String username, String password)`: Регистрирует нового пользователя, проверяя уникальность имени пользователя.
  - `logout(String authToken)`: Удаляет аутентификацию пользователя.
  - `getAuthentication(HttpRequest request)`: Извлекает аутентификацию на основе токена.

#### BlockService

- **Назначение**: Управляет блоками, которые содержатся на страницах.
- **Основные методы**:
  - `createBlock(Integer pageId, String type, String content)`: Создает новый блок для указанной страницы.
  - `findBlocksByPageId(Integer pageId)`: Получает список блоков, связанных с конкретной страницей.
  - `deleteBlock(Integer id)`: Удаляет блок по идентификатору.
  - `getBlockById(Integer id)`: Получает информацию о блоке по его идентификатору.
  - `updateBlock(Integer id, String content)`: Обновляет содержимое блока.

#### PageService

- **Назначение**: Управляет страницами, связанными с рабочими пространствами.
- **Основные методы**:
  - `createPage(Integer workspaceId, Integer parentPageId, String title, String content)`: Создает новую страницу в указанном рабочем пространстве.
  - `findPagesByWorkspaceId(Integer workspaceId)`: Получает список страниц для конкретного рабочего пространства.
  - `findPageById(Integer id)`: Находит страницу по идентификатору.
  - `updatePage(Integer id, String title, String content)`: Обновляет заголовок и содержимое страницы.
  - `deletePage(Integer id)`: Удаляет страницу по идентификатору.
  - `getPageById(Integer pageId)`: Получает информацию о странице по ее идентификатору.

#### PermissionService

- **Назначение**: Управляет разрешениями пользователей на страницы.
- **Основные методы**:
  - `setPermission(Integer userId, Integer pageId, String permissionType)`: Устанавливает разрешение для конкретного пользователя на страницу.
  - `findPermissionsByPageId(Integer pageId)`: Получает список разрешений для конкретной страницы.
  - `deletePermission(Integer id)`: Удаляет разрешение по идентификатору.

#### UserService

- **Назначение**: Обрабатывает загрузку пользователей по имени пользователя.
- **Основные методы**:
  - `loadUserByUsername(String username)`: Находит и возвращает пользователя по имени пользователя.

#### WorkspaceService

- **Назначение**: Управляет рабочими пространствами.
- **Основные методы**:
  - `createWorkspace(Integer ownerId, String name)`: Создает новое рабочее пространство.
  - `findWorkspacesByOwnerId(Integer ownerId)`: Получает список рабочих пространств, принадлежащих конкретному пользователю.
  - `getAllWorkspaces()`: Получает информацию обо всех рабочих пространствах в виде списка DTO.

## Эндпоинты API

#### 1. Эндпоинт Блоков
##### `GET /blocks/{id}`
- **Описание**: Получает блок по его ID.
- **Параметры**:
  - `id`: ID блока для получения.
- **Ответы**:
  - **200 OK**: Возвращает информацию о блоке.
  - **404 Not Found**: Блок не найден.

##### `PUT /blocks/{id}`
- **Описание**: Обновляет содержимое блока.
- **Параметры**:
  - `id`: ID блока для обновления.
- **Ответы**:
  - **200 OK**: Блок успешно обновлён.
  - **400 Bad Request**: Неверный ввод.
  - **404 Not Found**: Блок не найден.

##### `DELETE /blocks/{id}`
- **Описание**: Удаляет блок по его ID.
- **Параметры**:
  - `id`: ID блока для удаления.
- **Ответы**:
  - **204 No Content**: Блок успешно удалён.
  - **404 Not Found**: Блок не найден.

---

#### 2. Эндпоинт Логина
##### `POST /login`
- **Описание**: Аутентифицирует пользователя и возвращает токен.
- **Параметры**: 
  - `username`: Имя пользователя.
  - `password`: Пароль.
- **Ответы**:
  - **200 OK**: Успешная аутентификация, возвращает токен.
  - **400 Bad Request**: Неверные учетные данные.

---

#### 3. Эндпоинт Выхода
##### `POST /logout`
- **Описание**: Завершает сессию пользователя.
- **Параметры**: 
  - `Authorization`: Заголовок с токеном аутентификации.
- **Ответы**:
  - **200 OK**: Успешный выход.

---

#### 4. Эндпоинт Страниц
##### `GET /pages/{id}`
- **Описание**: Получает страницу по её ID.
- **Параметры**:
  - `id`: ID страницы для получения.
- **Ответы**:
  - **200 OK**: Возвращает информацию о странице.
  - **404 Not Found**: Страница не найдена.

##### `PUT /pages/{id}`
- **Описание**: Обновляет информацию о странице.
- **Параметры**:
  - `id`: ID страницы для обновления.
- **Ответы**:
  - **200 OK**: Страница успешно обновлена.
  - **400 Bad Request**: Неверный ввод.
  - **404 Not Found**: Страница не найдена.

##### `DELETE /pages/{id}`
- **Описание**: Удаляет страницу по её ID.
- **Параметры**:
  - `id`: ID страницы для удаления.
- **Ответы**:
  - **204 No Content**: Страница успешно удалена.
  - **404 Not Found**: Страница не найдена.

---

#### 5. Эндпоинт Прав
##### `POST /permissions`
- **Описание**: Устанавливает права доступа для пользователя к странице.
- **Параметры**:
  - `userId`: ID пользователя.
  - `pageId`: ID страницы.
  - `permissionType`: Тип прав доступа.
- **Ответы**:
  - **201 Created**: Права успешно установлены.
  - **400 Bad Request**: Неверный ввод.

---

#### 6. Эндпоинт Регистрации
##### `POST /register`
- **Описание**: Регистрация нового пользователя.
- **Параметры**:
  - `username`: Имя пользователя.
  - `password`: Пароль.
- **Ответы**:
  - **200 OK**: Пользователь успешно зарегистрирован.
  - **400 Bad Request**: Ошибка регистрации.

---

#### 7. Эндпоинт Рабочих Пространств
##### `GET /workspaces`
- **Описание**: Получает список всех рабочих пространств.
- **Ответы**:
  - **200 OK**: Возвращает список рабочих пространств.
  - **500 Internal Server Error**: Ошибка сервера.

##### `POST /workspaces`
- **Описание**: Создаёт новое рабочее пространство.
- **Параметры**:
  - `ownerId`: ID владельца.
  - `name`: Название рабочего пространства.
- **Ответы**:
  - **201 Created**: Рабочее пространство успешно создано.
  - **400 Bad Request**: Неверный ввод.

### Фильтры API

#### 1. Фильтр Аутентификации
##### `AuthenticationHttpFilter`
- **Описание**: Этот фильтр отвечает за проверку аутентификации пользователя для защищённых эндпоинтов.
- **Логика работы**:
  - При получении запроса фильтр проверяет наличие действительных учетных данных пользователя.
  - Если аутентификация не удалась, возвращается ответ с кодом **401 Unauthorized** и сообщением "Unauthorized".
  - Если аутентификация прошла успешно, запрос продолжается.

- **Ответы**:
  - **401 Unauthorized**: Возвращается, если аутентификация не удалась.
  
---

#### 2. Тестовый Фильтр
##### `TestFilterHandler`
- **Описание**: Этот фильтр предназначен для тестирования и демонстрации работы системы фильтрации.
- **Логика работы**:
  - При получении запроса выводит сообщение в консоль.
  - Устанавливает статус ответа **200 OK** и добавляет заголовок **Test-Header** с значением **Value**.

- **Ответы**:
  - **200 OK**: Всегда возвращается, независимо от состояния запроса.

---

#### 3. Результат Фильтрации
##### `DefaultHttpFilterResult`
- **Описание**: Стандартная реализация результата фильтрации.
- **Атрибуты**:
  - `proceed`: Указывает, нужно ли продолжать обработку запроса (true/false).
  - `errorResponse`: Возвращаемый ответ в случае ошибки аутентификации.

- **Методы**:
  - `proceed()`: Возвращает значение, указывающее, следует ли продолжать обработку.
  - `errorResponse()`: Возвращает ответ об ошибке, если аутентификация не удалась.


## API
### Типичный пользовательский сценарий использования приложения

1. **Аутентификация пользователя:**
   - Пользователь открывает приложение и вводит свои учетные данные (имя пользователя и пароль) для входа в систему.
   - Приложение отправляет POST-запрос на `/api/auth/login` с введенными данными.
   - Если аутентификация успешна, сервер возвращает токен доступа, который пользователь будет использовать для дальнейших запросов.

2. **Создание рабочего пространства:**
   - После успешного входа пользователь решает создать новое рабочее пространство.
   - Пользователь заполняет форму с названием рабочего пространства и отправляет POST-запрос на `/api/data/workspaces`.
   - Если создание прошло успешно, приложение отображает новое рабочее пространство в списке.

3. **Добавление страницы:**
   - Пользователь выбирает свое новое рабочее пространство и хочет добавить новую страницу.
   - Он заполняет заголовок и содержимое страницы и отправляет PUT-запрос на `/api/data/pages`, указав ID новой страницы.
   - Если страница создана успешно, она появляется в списке страниц рабочего пространства.

4. **Добавление блока на страницу:**
   - Пользователь открывает страницу и решает добавить текстовый блок.
   - Он вводит текст и отправляет PUT-запрос на `/api/data/blocks`, указав ID блока.
   - Если блок добавлен успешно, он отображается на странице.

5. **Обновление содержимого блока:**
   - Позже пользователь решает изменить содержимое текстового блока.
   - Он редактирует текст и отправляет PUT-запрос на `/api/data/blocks?id={blockId}`.
   - После успешного обновления содержимое блока обновляется на странице.

6. **Удаление блока или страницы:**
   - Пользователь больше не нуждается в определенном блоке или странице и решает удалить его.
   - Он отправляет DELETE-запрос на `/api/data/blocks?id={blockId}` или `/api/data/pages?id={pageId}`.
   - При успешном удалении соответствующий блок или страница исчезает из интерфейса.

7. **Выход из системы:**
   - Когда пользователь закончил работу с приложением, он отправляет POST-запрос на `/api/auth/logout` с заголовком авторизации.
   - Приложение завершает сессию, и пользователь возвращается на страницу входа.

### Основные сущности приложения

1. **Workspace (Рабочее пространство)**:
   - **DTO:** `WorkspaceDto`
   - **Параметры:**
     - `ownerId`: ID пользователя, владеющего рабочим пространством.
     - `name`: название рабочего пространства.
   - **Используется для:** Организации страниц и блоков.

2. **Page (Страница)**:
   - **DTO:** `PageDto`
   - **Параметры:**
     - `workspaceId`: ID рабочего пространства, к которому принадлежит страница.
     - `parentPageId`: ID родительской страницы (если есть).
     - `title`: заголовок страницы.
     - `content`: содержимое страницы.
   - **Используется для:** Содержания и организации информации в виде страниц.

3. **Block (Блок)**:
   - **DTO:** `BlockDto`
   - **Параметры:**
     - `pageId`: ID страницы, к которой принадлежит блок.
     - `type`: тип блока (например, текст, изображение).
     - `content`: содержимое блока.
   - **Используется для:** Разделения информации на более мелкие элементы, такие как текст или изображения.

4. **Permission (Разрешение)**:
   - **DTO:** `PermissionDto`
   - **Параметры:**
     - `userId`: ID пользователя, которому назначается разрешение.
     - `pageId`: ID страницы, к которой назначается разрешение.
     - `permissionType`: тип разрешения (например, `read`, `write`).
   - **Используется для:** Управления доступом пользователей к страницам.

### Задачи 

- **Аутентификация:**
  - Реализовать форму входа с обработкой аутентификации пользователя.
  - Сохранить токен доступа для последующих запросов.

- **Рабочие пространства:**
  - Создать интерфейс для отображения и управления рабочими пространствами.
  - Реализовать возможность создания новых рабочих пространств.

- **Страницы и блоки:**
  - Разработать функционал для добавления, редактирования и удаления страниц и блоков.
  - Обеспечить взаимодействие между страницами и блоками.

- **Управление разрешениями:**
  - Реализовать систему управления разрешениями для пользователей.

- **Выход из системы:**
  - Реализовать кнопку для выхода из системы с обработкой завершения сессии.


### Эндпоинт: `/api/data/blocks`

1. **GET** `/api/data/blocks?id={blockId}`  
   - **Описание:** Получение блока по его ID.
   - **Параметры запроса (Query Parameters):**  
     - `id`: integer (ID блока).
   - **Возвращает:**  
     - HTTP 200:  
       ```json
       {
         "pageId": 1,
         "type": "text",
         "content": "Example content"
       }
       ```  
     - HTTP 404:  
       ```json
       {
         "error": "Block not found"
       }
       ```

2. **PUT** `/api/data/blocks?id={blockId}`  
   - **Описание:** Обновление содержимого блока по его ID.
   - **Параметры запроса (Query Parameters):**  
     - `id`: integer (ID блока).
   - **Тело запроса (Request Body):**  
     ```json
     {
       "pageId": 1,
       "type": "text",
       "content": "Updated content"
     }
     ```
   - **Возвращает:**  
     - HTTP 200:  
       ```json
       {
         "status": "Block updated successfully"
       }
       ```  
     - HTTP 400:  
       ```json
       {
         "error": "Invalid block data"
       }
       ```

3. **DELETE** `/api/data/blocks?id={blockId}`  
   - **Описание:** Удаление блока по его ID.
   - **Параметры запроса (Query Parameters):**  
     - `id`: integer (ID блока).
   - **Возвращает:**  
     - HTTP 200:  
       ```json
       {
         "status": "Block deleted successfully"
       }
       ```  
     - HTTP 400:  
       ```json
       {
         "error": "Invalid block ID"
       }
       ```

### DTO для блока (`BlockDto`):

```json
{
  "pageId": 1,
  "type": "text",
  "content": "Example content"
}
```

- **pageId:** integer, ID страницы, к которой привязан блок.
- **type:** string, тип блока (например, текстовый, изображение и т.д.).
- **content:** string, содержимое блока.


### Эндпоинт: `/api/data/pages`

1. **GET** `/api/data/pages?id={pageId}`  
   - **Описание:** Получение страницы по ее ID.
   - **Параметры запроса (Query Parameters):**  
     - `id`: integer (ID страницы).
   - **Возвращает:**  
     - HTTP 200:  
       ```json
       {
         "workspaceId": 1,
         "parentPageId": null,
         "title": "Example Page",
         "content": "This is the content of the page."
       }
       ```  
     - HTTP 404:  
       ```json
       {
         "error": "Page not found"
       }
       ```

2. **PUT** `/api/data/pages?id={pageId}`  
   - **Описание:** Обновление данных страницы по ее ID.
   - **Параметры запроса (Query Parameters):**  
     - `id`: integer (ID страницы).
   - **Тело запроса (Request Body):**  
     ```json
     {
       "workspaceId": 1,
       "parentPageId": null,
       "title": "Updated Page Title",
       "content": "Updated content of the page."
     }
     ```
   - **Возвращает:**  
     - HTTP 200:  
       ```json
       {
         "status": "Page updated successfully"
       }
       ```  
     - HTTP 400:  
       ```json
       {
         "error": "Invalid page data"
       }
       ```

3. **DELETE** `/api/data/pages?id={pageId}`  
   - **Описание:** Удаление страницы по ее ID.
   - **Параметры запроса (Query Parameters):**  
     - `id`: integer (ID страницы).
   - **Возвращает:**  
     - HTTP 200:  
       ```json
       {
         "status": "Page deleted successfully"
       }
       ```  
     - HTTP 400:  
       ```json
       {
         "error": "Invalid page ID"
       }
       ```

### DTO для страницы (`PageDto`):

```json
{
  "workspaceId": 1,
  "parentPageId": null,
  "title": "Example Page",
  "content": "This is the content of the page."
}
```

- **workspaceId:** integer, ID рабочего пространства, к которому привязана страница.
- **parentPageId:** integer, ID родительской страницы (если есть).
- **title:** string, заголовок страницы.
- **content:** string, содержимое страницы.

### Эндпоинт: `/api/data/workspaces`

1. **GET** `/api/data/workspaces`  
   - **Описание:** Получение всех рабочих пространств.
   - **Возвращает:**  
     - HTTP 200:  
       ```json
       [
         {
           "ownerId": 1,
           "name": "Example Workspace"
         },
         {
           "ownerId": 2,
           "name": "Another Workspace"
         }
       ]
       ```
     - HTTP 500:  
       ```json
       {
         "error": "Internal Server Error"
       }
       ```

2. **POST** `/api/data/workspaces`  
   - **Описание:** Создание нового рабочего пространства.
   - **Тело запроса (Request Body):**  
     ```json
     {
       "ownerId": 1,
       "name": "New Workspace"
     }
     ```
   - **Возвращает:**  
     - HTTP 201 (Created):  
       ```json
       {
         "status": "Workspace created successfully"
       }
       ```  
     - HTTP 400 (Bad Request):  
       ```json
       {
         "error": "Invalid data for workspace creation"
       }
       ```

### DTO для рабочего пространства (`WorkspaceDto`):

```json
{
  "ownerId": 1,
  "name": "Example Workspace"
}
```

- **ownerId:** integer, ID пользователя, владеющего рабочим пространством.
- **name:** string, название рабочего пространства.

### Обработка запросов

1. **GET /api/data/workspaces**:
   - Метод `handleGetWorkspaces` возвращает список всех рабочих пространств с помощью сервиса `WorkspaceService`.
   - В случае успеха возвращает статус HTTP 200 с JSON-массивом всех рабочих пространств.
   - В случае ошибки возвращает статус HTTP 500.

2. **POST /api/data/workspaces**:
   - Метод обрабатывает POST-запрос для создания нового рабочего пространства.
   - Тело запроса парсится в `WorkspaceDto`.
   - Если создание прошло успешно — возвращает статус HTTP 201 (Created).
   - Если возникает ошибка — статус HTTP 400 (Bad Request).

### Эндпоинт: `/api/data/permissions`

1. **POST** `/api/data/permissions`  
   - **Описание:** Установка разрешения для пользователя на конкретную страницу.
   - **Тело запроса (Request Body):**  
     ```json
     {
       "userId": 1,
       "pageId": 42,
       "permissionType": "read"
     }
     ```
   - **Возвращает:**  
     - HTTP 201:  
       ```json
       {
         "status": "Permission created successfully"
       }
       ```  
     - HTTP 400:  
       ```json
       {
         "error": "Invalid permission data"
       }
       ```


### DTO для разрешений (`PermissionDto`):

```json
{
  "userId": 1,
  "pageId": 42,
  "permissionType": "read"
}
```

- **userId:** integer, ID пользователя, которому назначается разрешение.
- **pageId:** integer, ID страницы, к которой назначается разрешение.
- **permissionType:** string, тип разрешения (например, `read`, `write`, `admin`).


### Эндпоинт: `/api/auth/login`

1. **POST** `/api/auth/login`  
   - **Описание:** Аутентификация пользователя. При успешной аутентификации возвращается токен для дальнейших запросов.
   - **Тело запроса (Request Body):**  
     ```json
     {
       "username": "exampleUser",
       "password": "examplePassword"
     }
     ```
   - **Возвращает:**  
     - HTTP 200:  
       - **Заголовки:**  
         - `Authorization: <token>`
       - **Тело:**  
         ```json
         {
           "status": "Authentication successful"
         }
         ```
     - HTTP 400:  
       ```json
       {
         "error": "Invalid username or password"
       }
       ```

### DTO для аутентификации (`LoginDto`):

```json
{
  "username": "exampleUser",
  "password": "examplePassword"
}
```

- **username:** string, имя пользователя для входа в систему.
- **password:** string, пароль для входа в систему.

### Детали работы эндпоинта:

- При успешной аутентификации, с помощью метода `authenticate` из `AuthenticationService`, создаётся и возвращается токен в заголовке `Authorization`. Этот токен затем можно использовать для дальнейших запросов.
- Если имя пользователя или пароль неверны, возвращается ошибка 400 с сообщением об ошибке.

### Сценарии:

1. **Успешная аутентификация:**
   - Запрос:
     ```json
     {
       "username": "correctUsername",
       "password": "correctPassword"
     }
     ```
   - Ответ:
     - HTTP 200, заголовок `Authorization: <токен>`.

2. **Неудачная аутентификация (неверный пароль):**
   - Запрос:
     ```json
     {
       "username": "correctUsername",
       "password": "wrongPassword"
     }
     ```
   - Ответ:
     - HTTP 400, сообщение об ошибке:  
       ```json
       {
         "error": "Invalid username or password"
       }
       ```

### Эндпоинт: `/api/auth/logout`

1. **POST** `/api/auth/logout`  
   - **Описание:** Завершение сессии пользователя (выход из системы).
   - **Заголовки (Headers):**  
     - `Authorization`: string (токен сессии, который был выдан при логине).
   - **Возвращает:**  
     - HTTP 200:  
       ```json
       {
         "status": "Logged out successfully"
       }
       ```
     - HTTP 400:  
       ```json
       {
         "error": "Invalid or missing authorization token"
       }
       ```

### Детали работы эндпоинта:

- При вызове эндпоинта система получает токен из заголовка `Authorization` и завершает текущую сессию, используя метод `logout` из `AuthenticationService`.
- Если токен отсутствует или некорректен, сервер возвращает ошибку.

### Пример:

1. **Успешный выход из системы:**
   - Заголовки запроса:
     ```http
     Authorization: <valid_token>
     ```
   - Ответ:
     - HTTP 200, сообщение:  
       ```json
       {
         "status": "Logged out successfully"
       }
       ```

2. **Ошибка при выходе (некорректный токен):**
   - Заголовки запроса:
     ```http
     Authorization: <invalid_token>
     ```
   - Ответ:
     - HTTP 400, сообщение:  
       ```json
       {
         "error": "Invalid or missing authorization token"
       }
       ```
       

### Эндпоинт: `/api/auth/logout`

1. **POST** `/api/auth/logout`  
   - **Описание:** Завершение сессии пользователя (выход из системы).
   - **Заголовки (Headers):**  
     - `Authorization`: string (токен сессии, который был выдан при логине).
   - **Возвращает:**  
     - HTTP 200:  
       ```json
       {
         "status": "Logged out successfully"
       }
       ```
     - HTTP 400:  
       ```json
       {
         "error": "Invalid or missing authorization token"
       }
       ```

### Детали работы эндпоинта:

- При вызове эндпоинта система получает токен из заголовка `Authorization` и завершает текущую сессию, используя метод `logout` из `AuthenticationService`.
- Если токен отсутствует или некорректен, сервер возвращает ошибку.

### Пример:

1. **Успешный выход из системы:**
   - Заголовки запроса:
     ```http
     Authorization: <valid_token>
     ```
   - Ответ:
     - HTTP 200, сообщение:  
       ```json
       {
         "status": "Logged out successfully"
       }
       ```

2. **Ошибка при выходе (некорректный токен):**
   - Заголовки запроса:
     ```http
     Authorization: <invalid_token>
     ```
   - Ответ:
     - HTTP 400, сообщение:  
       ```json
       {
         "error": "Invalid or missing authorization token"
       }
       ```
       

### Эндпоинт: `/api/auth/register`

1. **POST** `/api/auth/register`  
   - **Описание:** Регистрация нового пользователя в системе.
   - **Тело запроса (Request Body):**  
     ```json
     {
       "username": "newuser",
       "password": "securepassword"
     }
     ```
   - **Возвращает:**  
     - HTTP 200:  
       ```json
       {
         "status": "User registered successfully"
       }
       ```
     - HTTP 400:  
       ```json
       {
         "error": "Username already exists or invalid data"
       }
       ```

## Установка и Запуск Приложения

### Шаги для запуска

1. **Клонирование репозитория**:
   ```bash
   git clone <URL_репозитория>
   cd <имя_папки_репозитория>
   ```
2. **Выполните команду для сборки проекта**:
```mvn clean package```

3. **Запуск приложения**: 
Запустите собранный файл JAR, указав порт, на котором будет развернут сервер:

- ```java -jar target/<имя_файла>.jar -p <номер_порта>```
- _Замените <имя_файла> на имя вашего JAR-файла и <номер_порта> на желаемый порт._

# Заключение

Каждое великое приключение начинается с безумной идеи, и это путешествие не стало исключением. Мы отправились в удивительное приключение по созданию многофункциональной платформы, где каждый эндпоинт и фильтр стали не просто строчками кода, а настоящими героями этой истории. 

Как и в любом эпическом произведении, нам пришлось столкнуться с множеством трудностей: от архитектурных решений, вызывающих головную боль, до бессонных ночей, полных сомнений и кофе, которые можно было бы пить прямо из ведра. Но, как говорят, «в трудностях рождаются лучшие идеи». Мы не только преодолели эти преграды, но и создали нечто удивительное с нуля.

Сегодня мы можем с гордостью смотреть на результат: полноценную платформу, готовую к действиям. Это не просто приложение — это наш совместный труд, который стал воплощением упорства и креативности. 

Так что, если вы, как и мы, когда-то задумывались о том, чтобы создать что-то свое, помните: путь может быть долгим и тернистым, но в конце концов вы достигнете своей цели. Удачи вам в ваших собственных приключениях, и не забывайте: каждый код — это история, ждущая своего рассказчика!

Спасибо за внимание и хорошего кода!

